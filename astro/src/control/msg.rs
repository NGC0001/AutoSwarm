use std::{option::Option, time::Duration};

use serde::{Deserialize, Serialize};

use super::super::kinetics::distance;
use super::{PosVec, Velocity};

// special id of ground control station
pub const GCS_ID: u32 = u32::max_value();

// the node id of a uav in a tree structure.
// it is: id(top) -> id -> ... -> id(this)
pub type Nid = Vec<u32>;

#[inline]
pub fn root_nid(id: u32) -> Nid { vec![id] }

#[inline]
pub fn id_of(nid: &Nid) -> u32 {
    *nid.last().unwrap()
}

#[inline]
pub fn root_id_of(nid: &Nid) -> u32 {
    *nid.first().unwrap()
}

#[inline]
pub fn is_root_node(nid: &Nid) -> bool {
    nid.len() == 1
}

pub fn parent_id_of(nid: &Nid) -> Option<u32> {
    let len = nid.len();
    match len {
        ..=1 => None,
        _ => Some(nid[len - 2]),
    }
}

#[inline]
pub fn is_id_valid_descendant_of(id: u32, p_nid: &Nid) -> bool {
    !p_nid.contains(&id)  // non-cyclic
}

// description of a node in the tree structure.
// need to be generated by that node, passed to its parent and children.
#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct NodeDesc {
    pub nid: Nid,  // structural id of node, down-flowing data
    pub p: PosVec,
    pub v: Velocity,
    pub swm: u32,  // the size of the swarm, down-flowing data
    pub tsk: Option<u32>,  // what task the node has, down-flowing data
}

impl NodeDesc {
    #[inline]
    pub fn get_id(&self) -> u32 { id_of(&self.nid) }

    #[inline]
    pub fn get_root_id(&self) -> u32 { root_id_of(&self.nid) }

    #[inline]
    pub fn is_root_node(&self) -> bool { is_root_node(&self.nid) }

    #[inline]
    pub fn get_parent_id(&self) -> Option<u32> { parent_id_of(&self.nid) }

    pub fn has_parent_of_id(&self, id: u32) -> bool {
        self.get_parent_id().is_some_and(|v| v == id)
    }

    #[inline]
    pub fn is_valid_ancestor_of(&self, id: u32) -> bool {
        is_id_valid_descendant_of(id, &self.nid)
    }

    #[inline]
    pub fn is_free(&self) -> bool { !self.has_task() }

    pub fn has_task(&self) -> bool {
        match self.tsk {
            Some(_) => true,
            None => false,
        }
    }

    pub fn has_task_of_id(&self, id: u32) -> bool {
        match self.tsk {
            Some(tid) => tid == id,
            None => false,
        }
    }

    #[inline]
    pub fn is_gcs(&self) -> bool { id_of(&self.nid) == GCS_ID }

    pub fn get_gcs_desc() -> NodeDesc {
        NodeDesc {
            nid: root_nid(GCS_ID),
            p: PosVec::zero(),
            v: Velocity::zero(),
            swm: 0,
            tsk: None,
        }
    }
}

#[derive(Deserialize, Serialize, Debug)]
pub struct JoinAppl {
    pub dtl: NodeDetails,
    pub src_tree: u32,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct AssignChildAppl {
    pub cid: u32,
    pub dtl: NodeDetails,
}

#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct Line {
    pub points: Vec<PosVec>,
    pub start: bool,  // whether there must be an uav at the start point of the line
    pub end: bool,  // whether there must be an uav at the end point of the line
}

impl Line {
    pub fn calc_length(&self) -> f32 {
        assert!(2 <= self.points.len());
        let mut len: f32 = 0.0;
        for i in 1..self.points.len() {
            len += distance(&self.points[i], &self.points[i - 1]);
        }
        assert!(0.0 < len);
        len
    }

    pub fn num_end_points(&self) -> u32 {
        (self.start as u32) + (self.end as u32)
    }

    // least number of uavs to form this line
    pub fn num_least_uavs(&self) -> u32 {
        let end_points = self.num_end_points();
        if end_points > 0 {
            end_points
        } else {
            1
        }
    }
}

#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct Task {
    pub id: u32,
    pub lines: Vec<Line>,
    pub duration: Duration,
    pub comm_point: Option<PosVec>,
}

// usual transitions: None -> Recv -> Algn -> Allc -> Succ -> None.
// other transitions: Recv/Algn/Allc/Succ -> Fail -> None,
//                    Succ -> Allc,
//                    Recv -> Allc (root node only)
// for root node, reception of a gcs task message means task allocated to root node,
// but the alignment not done yet, so the swarm is in Recv,
// after alignment done, the swarm changes to Allc, skipping Algn.
#[derive(Clone, Deserialize, Serialize, Debug)]
pub enum SubswarmTaskState {
    None,  // none has received task id,
           // in this case, the top node is in NodeState::Free.

    Recv(u32),  // the top node has received task id, all nodes have not received task id (not aligned to task id),
                // any node which does have received task id has not failed.
                // in this case, the top node is in NodeState:::InTask(id, TaskState::InProgress).

    Algn(u32),  // all nodes of subswarm have received task id (aligned) and are in NodeState::InTask(id, ..),
                // none has failed, all have not succeeded, and the top node has not been allocated a subtask.
                // in this case, the top node is in NodeState::InTask(id, TaskState::InProgress).

    Allc(u32),  // all nodes of subswarm have received task id and are in NodeState::InTask(id, ..),
                // none has failed, all have not succeeded, and the top node has been allocated a subtask.
                // in this case, the top node is in NodeState::InTask(id, TaskState::InProgress).

    Succ(u32),  // all nodes of subswarm have received task id and are in NodeState::InTask(id, ..),
                // all nodes have received their subtasks and have succeeded.
                // in this case, the top node is in NodeState::InTask(id, TaskState::Success).

    Fail(u32),  // the top node has received task id,
                // at least one node of subswarm has failed.
                // in this case, the top node is in NodeState::InTask(id, TaskState::Failure).
}

#[derive(Clone, Deserialize, Serialize, Debug)]
pub struct NodeDetails {
    pub subswarm: u32,  // the size of the subswarm, up-flowing data
    pub subswm_tsk: SubswarmTaskState,  // the task state of the subswarm, up-flowing data
}

impl NodeDetails {
    pub fn is_subswm_alignment_done_for_tsk(&self, tid: u32) -> bool {
        match self.subswm_tsk {
            SubswarmTaskState::Algn(id) |
            SubswarmTaskState::Allc(id) |
            SubswarmTaskState::Succ(id) |
            SubswarmTaskState::Fail(id) => id == tid,
            _ => false,
        }
    }

    pub fn is_subswm_allocation_done_for_tsk(&self, tid: u32) -> bool {
        // subswarm aligned to task tid, and top node has been allocated a subtask
        match self.subswm_tsk {
            SubswarmTaskState::Allc(id) |
            SubswarmTaskState::Succ(id) |
            SubswarmTaskState::Fail(id) => id == tid,
            _ => false,
        }
    }

    pub fn is_subswm_success_in_tsk(&self, tid: u32) -> bool {
        match self.subswm_tsk {
            SubswarmTaskState::Succ(id) => id == tid,
            _ => false,
        }
    }

    pub fn is_subswm_failure_in_tsk(&self, tid: u32) -> bool {
        match self.subswm_tsk {
            SubswarmTaskState::Fail(id) => id == tid,
            _ => false,
        }
    }
}

#[derive(Deserialize, Serialize, Debug)]
pub enum MsgBody {
    Empty,
    Connection(NodeDetails),  // sender keeps connection with receiver (parent and children)

    Join(JoinAppl),  // sender wants to set the receiver as its parent
    Accept,  // sender rejects the receiver as its child
    Reject,  // sender accepts the receiver as its child
    Leave,  // sender stops recognising the receiver as its parent

    ChangeParent(u32),  // sender sets a third node (on same tree) as the receiver's new parent
    AssignChild(AssignChildAppl),  // sender sets a third node (on same tree) as the receiver's new child

    Task(Task),  // sender is gcs, or sender relays a gcs task to the receiver (sender's parent)
    Subtask(Task),  // sender allocate a subtask to the receiver (sender's child)
}

#[derive(Deserialize, Serialize, Debug)]
pub struct Msg {
    pub sender: NodeDesc,  // node description of message sender
    pub to_ids: Vec<u32>,  // target message receivers, None means broadcasting
    pub body: MsgBody,
}

impl Msg {
    pub fn new_empty_msg(sender: NodeDesc) -> Msg {
        Msg {
            sender,
            to_ids: vec![],
            body: MsgBody::Empty,
        }
    }
}